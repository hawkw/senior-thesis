%
% $Id: ch03_design.tex
%
%   *******************************************************************
%   * SEE THE MAIN FILE "main.tex" FOR MORE INFORMATION.       *
%   *******************************************************************
%
\chapter{Design Considerations} \label{ch:design}

\epigraph{ A language that doesn't affect the way you think about programming
           is not worth knowing. }%
         { \textit{Epigrams on Programming}~\cite{Perlis:1982:SFE:947955.1083808} \\
          \textsc{Alan Perlis}}


\section{Design Goals} \label{sec:goals}

As is true for all software systems, when implementing a new programming language,

The following characteristics are major design goals for Mnemosyne:
\begin{enumerate}
    \item Support for systems programming
    \item Safety
    \item Performance
    \item Support for quality programming
    \item Expressiveness
\end{enumerate}

\paragraph{Support for systems programming}

As Mnemosyne is intended as a language for systems programming, it stands to reason that the first object of consideration in all our design choices is to ensure that the language is suitable for this purpose. Thus, we might wonder, what characteristics or traits of a language make it suitable for systems programming?

There are some low-hanging fruit here, some language characteristics that seem immediately obvious. Of course, a systems language must be compiled rather than interpreted; many systems programs must run with little or no runtime support from other software, so an interpreter or just-in-time compiler is out of the question.

In \citetitle{Shapiro:2006:PLC:1215995.1216004}, \citeauthor{Shapiro:2006:PLC:1215995.1216004} enumerates quite well a number of important qualities of systems software. Shapiro observes that performance, and thus data representation, are very important in systems programs, and that bulk input and output has a large impact on the performance of such software. He states that systems programs often ``operate in constrained memory'', which he observes to have ``unpleasant'' implications for garbage collection.~\cite[pp. 2]{Shapiro:2006:PLC:1215995.1216004} Finally, he also points out that systems programs retain a great deal of state over the course of their execution, which ``penalizes the performance of automatic storage reclamation strategies\footnote{\emph{Viz.} garbage collection}''~\cite[pp. 2]{Shapiro:2006:PLC:1215995.1216004}, as well as rendering unworkable the enforced purity or statelessness of functional languages such as Haskell.

\paragraph{Expressiveness}

Formally, the \textit{expressiveness} (or \textit{expressive power}) refers to the size of the set of all ideas or concepts capable of being communicated by a language. As a general-purpose programming language, Mnemosyne is intended to be Turing-complete; meaning that theoretically, all possible computations can be expressed in Mnemosyne.

In the context of general-purpose, Turing-complete languages, this term is more often used to refer to the \emph{ease} with which complex concepts can be expressed: a more expressive language is one wherein a complex idea requires less code. We could, then, perhaps informally define this kind of expressiveness as a ratio of things accomplished to lines of code. While this definition does not provide us with a measurable metric --- ``things accomplished'' is a bit too nebulous -- it neatly summarizes the idea that we should like for programmers to be able to accomplish a great deal in as few lines of code as possible.

\section{Characteristics} \label{sec:characteristics}

Programming languages may be categorized along a number of axes: whether it is compiled or interpreted, its typing discipline, what programming paradigms it is inteded to support, its method of memory management, and others.

Mnemosyne is a \textit{statically-typed} programming language, meaning that the analysis of the types of language constructs, such as variables and expressions, are known to the compiler at compile-time. This is in contrast to \textit{dynamically-typed} languages, such as a majority of the Lisp family, in which types are determined at runtime~\cite{Mitchell:2003:TT:1074100.1074885}.

A major advantage of static typing lies in its increased reliability. If we suppose that some operations are not supported on all types, and that attempting these operations on types which are not capable of carrying them out results in an error, as is the case in almost all programming languages, then such \textit{type errors} are a category of potential error which may occur in our programs. In a statically-typed language, the compiler has the capacity to reason about types, and thus these type errors can be detected at compile-time; while in a dynamically typed language, type errors will occur during the program's execution. Moving the detection of an entire category of errors from runtime to compile-time is a major boon to the language's reliability and safety~\cite{Mitchell:2003:TT:1074100.1074885,Mayer:2012:ESI:2398857.2384666}.

Furthermore, many programming languages use their type systems to encode other potential categories of errors in their type systems. The use of types in this manner can be used to detect security issues~\cite{Skalka:2000:SES:357766.351244} and concurrency defects~\cite{Sagonas:2010:USA:2175429.2175432} statically (i.e., at compile-time), rather than allowing these errors to remain undetected in software deployed into production.

Additionally, giving the compiler the capacity to reason about types permits us to perform a number of optimizations that are not possible in dynamically-typed languages.

In contrast, dynamic typing has frequently been observed to make writing amd modifying code less time-consuming~\cite{Mayer:2012:ESI:2398857.2384666,}. This quality is generally very useful for scripting languages, rapid prototyping, and educational programming languages. These domains lie outside of Mnemosyne's primary design goals, and dynamic typing is generally unsuitable for systems programming.
% \section{Test Environment}
% Algorithm \ref{widgmin} (from \cite{Fiori:2013}) shows a high-level description of an
% algorithm. There are many options for the display of
% pseudocode; this uses the {\tt algorithm2e} package \cite{Fiori:2013},
% but there are a number of others available at the Comprehensive \TeX\ Archive
% Network (\url{ctan.org}). Using any of these
% other packages might require the additon of one or more
% ``\verb$\usepackage{...}$'' commands in the main {\tt main.tex} file.

%   *******************************************************************
%   * SEE CHAPTER ch_01overview.tex FOR INFORMATION ON CONTROLLING    *
%   * PLACEMENT OF FIGURES.                                           *
%   *                                                                 *
%   * THERE ARE MANY DIFFERENT ALGORITHM ENVIRONMENTS. HERE, WE USE   *
%   * THE "algorithm2e" PACKAGE, BUT YOU SHOULD LOOK TO SEE IF        *
%   * OTHER PACKAGES BETTER MEET YOUR NEEDS. REGARDLESS OF WHICH      *
%   * PACKAGE YOU USE, EXPECT TO SPEND TIME READING THE USER MANUAL   *
%   * AS THERE ARE USUALLY A LARGE NUMBER OF PARAMETERS THAT CAN      *
%   * SIGNIFICANTLY AFFECT THE FINAL APPEARANCE OF THE ALGORITHM.     *
%   *******************************************************************
%
% \begin{algorithm}[htbp]
%  %\SetLine % For v3.9
%  \SetAlgoLined % For previous releases [?]
%  \KwData{this text}
%  \KwResult{how to write algorithm with \LaTeX2e }
%  initialization\;
%  \While{not at end of this document}{
%   read current\;
%   \eIf{understand}{
%    go to next section\;
%    current section becomes this one\;
%    }{
%    go back to the beginning of current section\;
%   }
%  }
%  \caption{How to write algorithms (from \cite{Fiori:2013})}
% \label{widgmin}
% \end{algorithm}

\section{Experiments}

% Figure \ref{javaprog} shows a Java program. There are many, many options for
% providing program listings; only a few of the basic ones are shown
% in the figure. Some thought must be given to making code suitable
% for display in a paper. In particular long lines, tabbed indents, and
% several other practices should be avoided. Figure \ref{javaprog} makes
% use of the {\tt listings} style file \cite{Heinz:2013}.

%   *******************************************************************
%   * SEE CHAPTER ch_01overview.tex FOR INFORMATION ON CONTROLLING    *
%   * PLACEMENT OF FIGURES.                                           *
%   *                                                                 *
%   * SEE THE MAIN FILE "main.tex" FOR THE "\lstset" COMMAND   *
%   * THAT DEFINES HOW PROGRAM LISTINGS WILL LOOK.                    *
%   *                                                                 *
%   * AS WITH EVERYTHING IN LATEX, LOOK AT THE USER MANUAL, SEARCH    *
%   * FOR EXAMPLES ONLINE, CUSTOMIZE TO GET A PLEASING LOOK.          *
%   *******************************************************************


% \begin{figure}[htbp]
% \centering
% \lstinputlisting{SampleProgUncommented.java}
% \caption{{\tt SampleProg}: A very simple program}
% \label{javaprog}
% \end{figure}

\section{Threats to Validity}
